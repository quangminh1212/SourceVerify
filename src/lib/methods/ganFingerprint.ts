import type { AnalysisMethod } from "../types";
import { gray } from "./pixelUtils";


/**
 * Generative Model Artifact Detection Signals (3 methods)
 * Detecting specific artifacts from GANs, Diffusion Models, and upsampling
 *
 * References:
 * - Marra et al., "Do GANs Leave Artificial Fingerprints?", IEEE MIPR 2019
 * - Zhang et al., "Detecting and Simulating Artifacts in GAN Fake Images", ICML Workshop 2019
 * - Corvi et al., "On the Detection of Synthetic Images Generated by Diffusion Models", ICASSP 2023
 */

import type { AnalysisMethod } from "../types";

function gray(pixels: Uint8ClampedArray, idx: number): number {
    return pixels[idx] * 0.299 + pixels[idx + 1] * 0.587 + pixels[idx + 2] * 0.114;
}

/**
 * Signal 36: GAN Fingerprint Detection
 * Marra et al. (2019) - Spectral artifacts unique to GANs
 * GANs leave periodic artifacts in frequency domain
 */
export function analyzeGANFingerprint(pixels: Uint8ClampedArray, width: number, height: number): AnalysisMethod {
    const size = Math.min(64, Math.min(width, height));
    const ox = Math.floor((width - size) / 2);
    const oy = Math.floor((height - size) / 2);

    // Extract center patch
    const patch = new Float64Array(size * size);
    for (let y = 0; y < size; y++)
        for (let x = 0; x < size; x++)
            patch[y * size + x] = gray(pixels, ((oy + y) * width + (ox + x)) * 4);

    // Row-wise DFT
    const halfSize = Math.floor(size / 2);
    const power = new Float64Array(halfSize + 1);

    for (let row = 0; row < size; row++) {
        for (let k = 0; k <= halfSize; k++) {
            let re = 0, im = 0;
            for (let n = 0; n < size; n++) {
                const angle = -2 * Math.PI * k * n / size;
                re += patch[row * size + n] * Math.cos(angle);
                im += patch[row * size + n] * Math.sin(angle);
            }
            power[k] += re * re + im * im;
        }
    }
    for (let k = 0; k <= halfSize; k++) power[k] /= size;

    // GANs create spectral peaks at specific frequencies
    // Look for unexpected peaks relative to smooth power law
    const logPower = Array.from(power, p => Math.log10(p + 1));

    // Moving average baseline
    let peakCount = 0;
    let peakStrengthSum = 0;
    const windowSize = 3;
    for (let k = windowSize; k < logPower.length - windowSize; k++) {
        let baseline = 0;
        for (let w = -windowSize; w <= windowSize; w++) {
            if (w !== 0) baseline += logPower[k + w];
        }
        baseline /= (windowSize * 2);
        const deviation = logPower[k] - baseline;
        if (deviation > 0.15) { // significant peak
            peakCount++;
            peakStrengthSum += deviation;
        }
    }

    const avgPeakStrength = peakCount > 0 ? peakStrengthSum / peakCount : 0;

    // GAN images: more spectral peaks
    let score: number;
    if (peakCount >= 5 && avgPeakStrength > 0.3) score = 85;
    else if (peakCount >= 3) score = 72;
    else if (peakCount >= 2) score = 58;
    else if (peakCount >= 1) score = 45;
    else score = 25;

    return {
        name: "GAN Fingerprint", nameKey: "signal.ganFingerprint",
        category: "generative", score, weight: 0.6,
        description: score > 55
            ? "Spectral peaks detected — characteristic fingerprint of GAN-based generation"
            : "No GAN spectral fingerprint detected — frequency spectrum appears natural",
        descriptionKey: score > 55 ? "signal.gan.ai" : "signal.gan.real",
        icon: "⚡",
        details: `Spectral peaks: ${peakCount}, Avg peak strength: ${avgPeakStrength.toFixed(3)}.`,
    };
}
