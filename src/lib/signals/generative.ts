/**
 * Generative Model Artifact Detection Signals (3 methods)
 * Detecting specific artifacts from GANs, Diffusion Models, and upsampling
 *
 * References:
 * - Marra et al., "Do GANs Leave Artificial Fingerprints?", IEEE MIPR 2019
 * - Zhang et al., "Detecting and Simulating Artifacts in GAN Fake Images", ICML Workshop 2019
 * - Corvi et al., "On the Detection of Synthetic Images Generated by Diffusion Models", ICASSP 2023
 */

import type { AnalysisSignal } from "../types";

function gray(pixels: Uint8ClampedArray, idx: number): number {
    return pixels[idx] * 0.299 + pixels[idx + 1] * 0.587 + pixels[idx + 2] * 0.114;
}

/**
 * Signal 36: GAN Fingerprint Detection
 * Marra et al. (2019) - Spectral artifacts unique to GANs
 * GANs leave periodic artifacts in frequency domain
 */
export function analyzeGANFingerprint(pixels: Uint8ClampedArray, width: number, height: number): AnalysisSignal {
    const size = Math.min(64, Math.min(width, height));
    const ox = Math.floor((width - size) / 2);
    const oy = Math.floor((height - size) / 2);

    // Extract center patch
    const patch = new Float64Array(size * size);
    for (let y = 0; y < size; y++)
        for (let x = 0; x < size; x++)
            patch[y * size + x] = gray(pixels, ((oy + y) * width + (ox + x)) * 4);

    // Row-wise DFT
    const halfSize = Math.floor(size / 2);
    const power = new Float64Array(halfSize + 1);

    for (let row = 0; row < size; row++) {
        for (let k = 0; k <= halfSize; k++) {
            let re = 0, im = 0;
            for (let n = 0; n < size; n++) {
                const angle = -2 * Math.PI * k * n / size;
                re += patch[row * size + n] * Math.cos(angle);
                im += patch[row * size + n] * Math.sin(angle);
            }
            power[k] += re * re + im * im;
        }
    }
    for (let k = 0; k <= halfSize; k++) power[k] /= size;

    // GANs create spectral peaks at specific frequencies
    // Look for unexpected peaks relative to smooth power law
    const logPower = Array.from(power, p => Math.log10(p + 1));

    // Moving average baseline
    let peakCount = 0;
    let peakStrengthSum = 0;
    const windowSize = 3;
    for (let k = windowSize; k < logPower.length - windowSize; k++) {
        let baseline = 0;
        for (let w = -windowSize; w <= windowSize; w++) {
            if (w !== 0) baseline += logPower[k + w];
        }
        baseline /= (windowSize * 2);
        const deviation = logPower[k] - baseline;
        if (deviation > 0.15) { // significant peak
            peakCount++;
            peakStrengthSum += deviation;
        }
    }

    const avgPeakStrength = peakCount > 0 ? peakStrengthSum / peakCount : 0;

    // GAN images: more spectral peaks
    let score: number;
    if (peakCount >= 5 && avgPeakStrength > 0.3) score = 85;
    else if (peakCount >= 3) score = 72;
    else if (peakCount >= 2) score = 58;
    else if (peakCount >= 1) score = 45;
    else score = 25;

    return {
        name: "GAN Fingerprint", nameKey: "signal.ganFingerprint",
        category: "generative", score, weight: 0.6,
        description: score > 55
            ? "Spectral peaks detected — characteristic fingerprint of GAN-based generation"
            : "No GAN spectral fingerprint detected — frequency spectrum appears natural",
        descriptionKey: score > 55 ? "signal.gan.ai" : "signal.gan.real",
        icon: "⚡",
        details: `Spectral peaks: ${peakCount}, Avg peak strength: ${avgPeakStrength.toFixed(3)}.`,
    };
}

/**
 * Signal 37: Upsampling Artifact Detection
 * Zhang et al. (ICML 2019) - Checkerboard artifacts from transposed convolutions
 * AI models using upsampling leave periodic grid artifacts
 */
export function analyzeUpsamplingArtifact(pixels: Uint8ClampedArray, width: number, height: number): AnalysisSignal {
    // Detect checkerboard patterns at various scales (2x2, 4x4)
    let checkerboardScore2 = 0;
    let checkerboardScore4 = 0;
    let totalSamples = 0;
    const step = Math.max(4, Math.floor(Math.min(width, height) / 120));

    for (let y = 2; y < height - 2; y += step) {
        for (let x = 2; x < width - 2; x += step) {
            // 2x2 checkerboard pattern detection
            const g00 = gray(pixels, (y * width + x) * 4);
            const g01 = gray(pixels, (y * width + x + 1) * 4);
            const g10 = gray(pixels, ((y + 1) * width + x) * 4);
            const g11 = gray(pixels, ((y + 1) * width + x + 1) * 4);

            // Checkerboard: diagonal similar, adjacent different
            const diagSim = Math.abs(g00 - g11) + Math.abs(g01 - g10);
            const adjDiff = Math.abs(g00 - g01) + Math.abs(g00 - g10);

            if (adjDiff > 0) {
                const checkRatio = diagSim / adjDiff;
                if (checkRatio < 0.3 && adjDiff > 3) checkerboardScore2++;
            }

            // 4x4 pattern
            if (x + 3 < width && y + 3 < height) {
                let pattern4x4 = 0;
                for (let dy = 0; dy < 4; dy++) {
                    for (let dx = 0; dx < 4; dx++) {
                        const g = gray(pixels, ((y + dy) * width + (x + dx)) * 4);
                        const expected = ((dy + dx) % 2 === 0) ? g00 : g01;
                        pattern4x4 += Math.abs(g - expected);
                    }
                }
                if (pattern4x4 < 20 * 16) checkerboardScore4++;
            }

            totalSamples++;
        }
    }

    const checkRatio2 = totalSamples > 0 ? checkerboardScore2 / totalSamples : 0;
    const checkRatio4 = totalSamples > 0 ? checkerboardScore4 / totalSamples : 0;
    const combinedRatio = checkRatio2 * 0.6 + checkRatio4 * 0.4;

    let score: number;
    if (combinedRatio > 0.3) score = 85;
    else if (combinedRatio > 0.15) score = 72;
    else if (combinedRatio > 0.08) score = 58;
    else if (combinedRatio > 0.03) score = 42;
    else score = 22;

    return {
        name: "Upsampling Artifacts", nameKey: "signal.upsamplingArtifact",
        category: "generative", score, weight: 0.5,
        description: score > 55
            ? "Checkerboard upsampling artifacts detected — common in neural network generation"
            : "No upsampling artifacts found — image pixel structure appears natural",
        descriptionKey: score > 55 ? "signal.upsampling.ai" : "signal.upsampling.real",
        icon: "⊞",
        details: `2x2 check ratio: ${checkRatio2.toFixed(3)}, 4x4 ratio: ${checkRatio4.toFixed(3)}, Combined: ${combinedRatio.toFixed(3)}.`,
    };
}

/**
 * Signal 38: Diffusion Model Artifact Detection
 * Corvi et al. (ICASSP 2023) - Unique artifacts from diffusion denoising
 * Diffusion models create specific mid-frequency anomalies
 */
export function analyzeDiffusionArtifact(pixels: Uint8ClampedArray, width: number, height: number): AnalysisSignal {
    // Diffusion models produce smooth mid-frequency content with sharp edges
    // Detect by analyzing the ratio of mid-to-high frequency content

    const blockSize = 16;
    const blocksX = Math.floor(width / blockSize);
    const blocksY = Math.floor(height / blockSize);
    let smoothMidCount = 0;
    let sharpTransitionCount = 0;
    let totalBlocks = 0;
    const step = Math.max(1, Math.floor(blocksX * blocksY / 200));

    for (let by = 0; by < blocksY; by += step) {
        for (let bx = 0; bx < blocksX; bx += step) {
            let midFreqEnergy = 0;
            let highFreqEnergy = 0;
            let edgeCount = 0;
            let count = 0;

            for (let y = by * blockSize + 1; y < (by + 1) * blockSize - 1; y++) {
                for (let x = bx * blockSize + 1; x < (bx + 1) * blockSize - 1; x++) {
                    const center = gray(pixels, (y * width + x) * 4);
                    const right = gray(pixels, (y * width + x + 1) * 4);
                    const down = gray(pixels, ((y + 1) * width + x) * 4);
                    const right2 = x + 2 < width ? gray(pixels, (y * width + x + 2) * 4) : center;

                    // First derivative (mid frequency)
                    const d1 = Math.abs(right - center);
                    // Second derivative (high frequency)
                    const d2 = Math.abs(right2 - 2 * right + center);

                    midFreqEnergy += d1;
                    highFreqEnergy += d2;
                    if (d1 > 15) edgeCount++;
                    count++;
                }
            }

            totalBlocks++;
            if (count > 0) {
                const midAvg = midFreqEnergy / count;
                const highAvg = highFreqEnergy / count;
                const edgeRatio = edgeCount / count;

                // Diffusion artifact: smooth mid-frequency but sharp edges
                if (midAvg < 5 && edgeRatio > 0.02) smoothMidCount++;
                if (highAvg < 1 && midAvg > 2) sharpTransitionCount++;
            }
        }
    }

    const smoothRatio = totalBlocks > 0 ? smoothMidCount / totalBlocks : 0;
    const transitionRatio = totalBlocks > 0 ? sharpTransitionCount / totalBlocks : 0;
    const diffusionScore = smoothRatio * 0.5 + transitionRatio * 0.5;

    let score: number;
    if (diffusionScore > 0.5) score = 82;
    else if (diffusionScore > 0.3) score = 68;
    else if (diffusionScore > 0.15) score = 55;
    else if (diffusionScore > 0.05) score = 40;
    else score = 22;

    return {
        name: "Diffusion Artifacts", nameKey: "signal.diffusionArtifact",
        category: "generative", score, weight: 0.5,
        description: score > 55
            ? "Mid-frequency smoothing with sharp edges detected — pattern consistent with diffusion models"
            : "No diffusion model artifacts detected — frequency structure appears natural",
        descriptionKey: score > 55 ? "signal.diffusion.ai" : "signal.diffusion.real",
        icon: "∞",
        details: `Smooth ratio: ${smoothRatio.toFixed(3)}, Transition ratio: ${transitionRatio.toFixed(3)}, Score: ${diffusionScore.toFixed(3)}.`,
    };
}
